
<!DOCTYPE html>
<html>
    <head>
    <title>Physical Computing Syllabus </title>
    <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:300' rel='stylesheet' type='text/css'> -->
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
     <!-- Custom styles for this template -->
    <link href="mycss/starter-template.css" rel="stylesheet">
    
    <!-- <link href="mycss/grid.css" rel="stylesheet"> -->

    <script src = "https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>

    <script src = "https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.0/p5.min.js" type="text/javascript"></script>
    <script src = "https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.0/addons/p5.dom.min.js" type="text/javascript"></script>
    <script src = "https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.0/addons/p5.sound.min.js" type="text/javascript"></script>

<!-- 
 
    <script src = "libraries/p5.js" type="text/javascript"></script>
    <script src = "libraries/p5.dom.js" type="text/javascript"></script>
    <script src = "libraries/p5.sound.js" type="text/javascript"></script>

-->

    <script src="js/sketch.js" type="text/javascript"></script>
    <link href="mycss/mycss.css" rel="stylesheet">
    <style> body {padding: 50px; margin: 0;} canvas {vertical-align: top;} </style>

    </head>

<!--//////////////////////////////////////////////////////////////////////////////////////////-->
<!--HEADER AND NAVIGATION-->
<!--//////////////////////////////////////////////////////////////////////////////////////////-->

    <body>
        <div class="container">
        <nav class="nav navbar navbar-default navbar-fixed-top" id="myTabs">
            <div class="navbar-brand">
                <strong>Medium Workshop: Physical Computing </strong>
            </div>

            <ul class="nav navbar-nav navbar-right">

                <li><a href="index.html"> Syllabus</a></li>
                <li><a href="labs.html">Labs</a></li>
                <li><a href="materials.html">Resources</a></li>
                <li><a href="students.html">Blogs</a></li>
                <li><a href="notes.html">Class Notes</a></li>
                <li><a href="final.html">Final</a></li>
                <li><a href="course.html">Overview</a></li>
                
                
            </ul>

        </nav>
    </div>     
      
 <!-- CONTENT -->       


<!--////////////////////////////////////////////////////////////////////////////////////////////////////-->
<!-- LABS & ASSIGNMENTS  LABS & ASSIGNMENTS  LABS & ASSIGNMENTS  LABS & ASSIGNMENTS  LABS & ASSIGNMENTS -->
<!--////////////////////////////////////////////////////////////////////////////////////////////////////-->


    <div class="container" id="notes">
        <span id="schedule" class="anchor"></span>
        <div class="page-header">
            <h2 class="noselect">Class Notes</h2>
        </div>
        <div class="container-fluid" id="notes-detailed">
            <div class="container" id="class1">
                <div class="page-header"><h3>Class 1: Electricty and First Circuit</h3></div>
                
                <ul><strong>Physical Computing and Electricty:</strong></ul>
                    <ul>
                        <li> <h4>How the computer sees you</h4></li>
                        <br>
                        <img src="https://lh4.googleusercontent.com/PiTe7qDN0e_BSsoBVNZhJUroHZlNxV_Yk1X1IWo21VBQkNOk1PjTXrVENK-0pVvek0EisHz1j2PXfEmCAuZqoLzIxksr6u5vzQKK8QxfHTVbK5pmJwc">
                        <h4><li>Anatomy of a Breadboard</li></h4>
                        <br>       
                        <a href="imgs/breadboard2.jpg"><img src="imgs/breadboard2.jpg" width="50%" height="50%"></a>

                        <li>VIDEO: <a href="https://www.youtube.com/watch?v=w0c3t0fJhXU">Explanation of Breadboards</a></li>
                        <li><a href="https://learn.sparkfun.com/tutorials/how-to-read-a-schematic">Sparkfun Reading schematics page</a></li>
                        <li><a href="https://itp.nyu.edu/physcomp/Labs/Components"> ITP Lab: </a>Components</li>
                        <li><a href="https://itp.nyu.edu/physcomp/Labs/Breadboard"> ITP Lab: </a>Setting up a breadboard</li>
                        <li><a href="https://itp.nyu.edu/physcomp/Labs/Electronics"> ITP Lab: </a>Using a multimeter (use Arduino to power the board, ignore the Voltage regulator)</li>
                        <li>VIDEO: <a href="https://www.youtube.com/watch?v=rPGoMbVSUu8"> Using a multimeter</a></li>
                        <li><a href="https://itp.nyu.edu/physcomp/Labs/Soldering"> ITP Lab: </a>Soldering</li>
                        
                    </ul>

                <li><strong>Your first Circuit:</strong></li>
                    <ul>
                        <li><a href="https://itp.nyu.edu/physcomp/Labs/Components"> ITP Lab: </a>Components</li>
                        <li><a href="https://itp.nyu.edu/physcomp/Labs/Breadboard"> ITP Lab: </a>Setting up a breadboard</li>
                        <li><a href="https://itp.nyu.edu/physcomp/Labs/Electronics"> ITP Lab: </a>Using a multimeter (use Arduino to power the board, ignore the Voltage regulator)</li>
                        <li><a href="https://itp.nyu.edu/physcomp/Labs/Soldering"> ITP Lab: </a>Soldering</li>
                        <li><a href="https://github.com/drios42/pcompdiap2016/blob/gh-pages/readings/physcompIgoeOsullivan.pdf ">Physical Computing: Introduction, Ch1, Ch2, Ch3</a></li>
                    </ul>
            </div>

            <div class="container" id="class2">
                <h3>Class 2: Electricity Continued and Input/Output </h3>
                
                <li><strong>Doings:</strong></li>
                    <ul>
                        <li>Create another circuit or modify your existing circuit (still with no hands), this time using the arduino to read your input and to affect your output</li>    
                    </ul>

                <li><strong>Schematics:</strong></li>
                <li>Here is our schematic from class<br></li>   
                <ul>
                     <li><a href="imgs/swtledschem.png"><img src="imgs/swtledschem.png" width="50%" height="50%"></a><a href="imgs/swtledbb.png"><img src="imgs/swtledbb.png" width="25%" height="25%"></li>
                </ul>

                <li><strong>Resources:</strong></li>
                    <ul>
                        <li><a href="notes.html">Class Notes</a></li>
                        <li><a href="https://itp.nyu.edu/physcomp/lessons/microcontrollers/digital-input-output/">ITP Lab: Digital Input Output</a></li>
                        <li><a href="https://itp.nyu.edu/physcomp/lessons/microcontrollers/microcontrollers-the-basics/"> ITP Lab: </a>Microcontrollers</li>
                        <li>VIDEO: <a href="https://vimeo.com/86548673">Digital Input</a></li>
                        <li>VIDEO: <a href="https://vimeo.com/86534049">Digital Output</a></li>
                    </ul>


            </div>

             <div class="container" id="class3">
                <h3>Class 3: On Off and In Between </h3>
                <li><strong>Arduino Code:</strong></li>
                    <ul>
                        <li>Our code is like a blueprint, or a list of commands that the arduino will execute.  For the most part we can imagine that the arduino is reading our code line by line from top to bottom.  The Arduino will excute the code exactly as it is written, in order, line by line.  It is our job as programmers to remember that while the computer is fast and powerful, it is also very simplistic in how it reads and executes our code.</li> 

                        <li>Our code uses variables to store information and functions to do stuff with that information.  It also has a variety of logical operators and comparitors that allow us to compare things and program different behaviors for different situations.</li>   
                    </ul>


                <li><strong>Syntax:</strong></li>
                    <ul>
                        <li>Arduino code is text based, and requires us to remember certain keywords and punctuation marks and write them in the correct order.  If we forget certain words or punctuation, or if we place them in the wrong order, our code will not compile and we will get an error</li> 

                        <li><code>{ }</code> Curly brackets are like containers for our functions. If we want excute a function we have to put our commands in between the brackets of that function<br>
                        <ul><code>
                            void setup(){<br> 
                            int led = 7;<br>
                            pinMode(led, OUTPUT);<br>
                        }
                        </code></ul></li><br>

                        <li><code>;</code> Semicolons are how we end each line of a declaration or function call.  Always check for missing semicolons</li>  

                        <li><code>()</code> Parentheses on their own are used to separate mathematical order of operations<br><code> <ul>x = (x +50)*3; </code></ul></li><br>

                        <li><code><em>name</em>(<em>parameters</em>)</code> Parentheses after a name indicate we are executing a function.  Some functions also require parameters inside the parentheses in order for the function to execute properly<br>
                            <ul>
                                <code>
                                    pinMode(7, OUTPUT);<br>
                                </code>
                            </ul>
                        </li> 

                        <li><code>//</code> Two slashes will comment out the text that follows it. Anything written after <code>// will not be interpreted by the arduino compiler</code>  This is useful for making notes to yourself and to other programmers who may read your code</li>  

                    <!--     <li><code>char</code> Stands for <em>character</em>. This variable type is capable of storing alpha-numeric characters.  But remember! In arduino the <code>char</code> type stores your letters and numerals as ascii encoded values.  For example the character<code>'A'</code> will have a coded value of <code>65</code>. the character <code>3</code> will be encoded</li> 

                        <li><code>String</code> Is an object that lets you store words or sentences.  Strings are stored as arrays of characters.</li>  -->

                    </ul>

                    <li><strong>Programming logic, and variables in Arduino:</strong></li>
                    <ul>
                        <li><strong><code>type nameOfVariable</code></strong> All variables have a "type" and a "name." The <strong>type</strong> determines what kind of information it can store.  The <strong>name</strong> is the label we assign to that information so that the arduino knows where to find that information. <br> 
                        <li>Variables have to be declared before we can use them.

                            <li>We declare variables like this:<code>
                                <ul> <br>int x;<br></ul></code><li>

                            <li>We can also assign a variable a value when we declare it:<code>
                                  <ul> <br>int x = 0;<br></ul></code></li>

                            <li>For now, we can declare our variable above our setup and loop functions.  This will ensure that they are useable in all parts of our sketch<br>
                                <code>
                                   int x = 25;<br>
                                   void setup(){<br>
                                    }<br>
                                       void loop(){<br>
                                    }<br>
                                    
                                    </code><br>
                            </li>
                        </li> 

                         
                            <li>Similar to algebra class. If we say <em> x = 25</em></li> 
                            <li>Then we ask what is <em> x + 1</em></li>
                            <li>We know the answer to be 26</li><br>
                            <li>In the arduino we can update a variable like so:</li>  <br>

                
                             <ul>
                                <code>
                                 int x = 25;<br>
                                   void setup(){<br>
                                    x = x + 2;<br>
                                    }
                                    </code><br>
                            </ul>
                                When setup() finishes running the variable <code>x</code> will be storing the number 27 
                            
                            <ul>
                              <br><code>
                              int x = 25;<br>
                              void loop(){<br>
                                x = x + 2;<br>
                                    }
                                    </code><br>
                            </ul>
                                    If we update inside the loop, x will start out at 25 on startup and it will increase by 2 each time the loop executes
                          

                            <ul>
                                <br><code>
                                int larry = 25;<br>
                                void setup(){<br>
                                larry = larry + 2;<br>
                                }
                                    </code><br>
                            </ul>
                                Now the variable <code>larry</code> is storing the number 27
                           <br>

                        </li>
                        
                        <li><code>int</code> Stands for <em>integer</em>. This type is capable of storing whole numbers. Numbers can be both negative and positive. Has limited range of -32,768 - 32,767</li>  
                        <li><code>float</code> Stands for <em>floating point</em>. This variable type is capable of storing decimal numbers both negative and positive</li>  

                        <li><code>bool</code> or <code>boolean</code> This variable type is capable of storing either <code>true</code> and <code>false</code> statements,  true will evaluate to <code>1</code>, false will evaluate to <code>0</code></li>  
                        
                        <li><code>long</code> Same as <code>int</code> but capable of storing larger numbers</li>
                    <!--     <li><code>char</code> Stands for <em>character</em>. This variable type is capable of storing alpha-numeric characters.  But remember! In arduino the <code>char</code> type stores your letters and numerals as ascii encoded values.  For example the character<code>'A'</code> will have a coded value of <code>65</code>. the character <code>3</code> will be encoded</li> 

                        <li><code>String</code> Is an object that lets you store words or sentences.  Strings are stored as arrays of characters.</li>  -->

                    </ul>

                <li><strong>Functions:</strong></li>
                    <ul>
                        <li><code>void setup(){}</code> Only runs once upon arduino bootup. Certain functions only need to run once in your code.  These functions go in setup()</li>  

                        <li><code>void loop(){}</code> Executes over and over and over and over forever (or until you reboot or unplug your arduino). The loop is the master of your program and will control nearly all interactivity in your code</li>  

                    </ul>
                    
                

                <li><strong>Comparitors and Operators:</strong></li>
                    <ul>
                        <li><code> if(){}</code> If statements, check to see if a condition (that you define) is met.  If the condition is met, the code inside the if statement will execute.  If the condition is not met, the code inside the if statement will get skipped, and will not execute.  If statements let you make dynamic code.</li>  

                        <li><code> = </code> Single equals, assigns the value on the right to the variable on the left  </li> 

                        <li><code> == </code> Double equals, compares the two values to eachother. Returns true if they are equal false if they are not </li> 

                        <li><code> > </code> Greater than, compares the two values to eachother. Returns true if the right is greater than the left </li> 

                        <li><code> >= </code> Greater than or equal, compares the two values to eachother. Returns true if the right side value is greater than or equal to the left side value</li> 

                        <li><code> < </code> Less than, compares the two values to eachother. Returns true if the right side value is less than the left </li> 

                         <li><code> <= </code> Less than or equal, compares the two values to eachother. Returns true if the right side value is less than or equal to the left side value </li> 

                        <li><code> != </code> Not equal, compares the two values to eachother. Returns true if they are NOT equal false if they are equal</li> 

                        <li><code> && </code> AND. Compare multiple conditions in one line.  Both conditions must be met in order to return true</li> 

                        <li><code> || </code> OR. Compare multiple conditions in one line. Returns true if either condition is met</li> 

                    </ul>

            </div>
            <div class="container" id="class4">
                <h3>Class 4: Timers and Booleans </h3>
                 <ul>
                   <a href="https://github.com/drios42/pcompdiap2016/tree/gh-pages/code/Class%2004%20Variables%20Timers%20Booleans">Reference Code Here</a></ul>
                   <br>
                <li><strong>Timing without Delays:</strong></li><br>
               
                    <ul>
                        The arduino runs constantly at a high speed.  Which is extremely usefull for reading sensors and executing our code.  However sometimes we want time based interactivity.  Sometimes we want things to happen at intervals, or with pauses, or with delays.<br><br>
                        Up until now we've used the <code>delay()</code> function to pause our code between our desired actions.  However the <code>delay()</code> function is a <strong>blocking</strong> function.  This means that it stops all of our code from running until <code>delay()</code> has finished executing.  

                        This means that if I write a line of code that says: <br><br> <code>delay(2000);</code><br><br> My sketch will now stop all actions until the 2 seconds of delay are done.<br><br>

                        If we want to have time based functionality without stopping the rest of our program from running we need to set up a <a href="https://github.com/drios42/pcompdiap2016/blob/gh-pages/code/Class%2004%20Variables%20Timers%20Booleans/timeWithOutDelay/timeWithOutDelay.ino">timer.</a><br><br>

                        Time in the arduino is like a stopwatch, it starts at 0 on startup and increases continuously by the millisecond (0.001 seconds!).  We can use the <code>millis()</code> function to read out how much time (in milliseconds) has passed since our startup.<br><br>

                        We can set up a system that triggers events by updating a "timestamp" variable at a certain interval.<br><br>

                        First, make variables to store the current time (aka <code>millis()</code>) , and the last checked time (lastTime). Also make a variable for the interval at which we want to trigger actions, mine will be every 500 milliseconds.  Then at the end of our <code>setup()</code> function set the "timestamp" equal to millis.  Setting <code>lastTime = millis();</code> ensures that our initial "timestamp" (our variable <code>lastTime</code>) is set right when we start running our sketch<br><br>
                        <pre>
                            int interval = 500; // set interval for triggering actions (maybe blink an LED)
                            long currentTime; // variable to store our millis(), use long instead of int 
                            long lastTime; // timestamp for the last time we triggered, use long instead of int
                    
                            void setup() { 
                              Serial.begin(9600); // start serial so we can debug 
                              lastTime = millis(); // set our "timestamp" when we turn on our program.
                            }
                        </pre>
                        <br>
                        Now in the loop we want to update our current time constantly so we can keep track of time.  Then use an "if" statement to see how much time has passed. Subtracting our "timestamp" variable <code>lastTime</code> from <code>millis()</code> will tell us how much time has passed between starting the sketch and that moment in time.<br><br>
                        Now we compare.  Is the passage of time greater than the amount of time we want to wait in order to trigger something (aka <code>interval</code>)?  if so, do something like print out "Hey 500 millis has passed".  And then <strong>most importantly</strong> reset our timestamp at that moment so that when the loop restarts our comparison of <code>currentTime - lastTime</code> will equal 0, and force the sketch to wait 500 milliseconds (or whatever you make your interval amount) until the next time it triggers an action
                        <br><br>
                        <pre>
                        void loop() {

                          currentTime = millis(); // continuously update the 

                          if (currentTime - lastTime > interval) { // check the passage of time
                            Serial.println("Hey 500 millis has passed") // trigger a serial println
                            lastTime = millis(); // update the timestamp so we can continue keeping track
                          }
                        }
                        </pre>
                    </ul>
                    <li><strong>Using Booleans:</strong></li>
                    <ul>
                        We can add more functionality to the code above.  Lets say we want to light up an led without using delays.  We can make a boolean that will act as a trigger for our led.  Booleans can only be either true or false, so our led will only be able to be on or off
                        <pre>
                            boolean ledState;
                        </pre>
                        Set it false just to start off
                         <pre>
                            void setup() { 
                              Serial.begin(9600); // start serial so we can debug 
                              lastTime = millis(); // set our "timestamp" when we turn on our program.
                              ledState = false; // start with our led trigger off
                            }
                        </pre>

                        Now in the loop change the state of the led trigger each time we reach our interval.  I will use a shorthand that looks like this <code>ledState = !ledState</code><br><br>
                        <code>!</code> is the NOT operator.  When used to set the state of a boolean it changes the booleans state to be not what it previously was. So if it was just <code>false</code> that means it is not <code>true</code>. so it will update and become true (and vice-versa) when this line of code is called <code>ledState = !ledState</code>
                        <pre>
                         void loop() {

                          currentTime = millis(); // continuously update the 

                          if (currentTime - lastTime > interval) { // check the passage of time
                            Serial.println("Hey 500 millis has passed") // trigger a serial println
                            
                            ledState = !ledState  // change ledState to the opposite of what it was previously

                            lastTime = millis(); // update the timestamp so we can continue keeping track

                          }
                        }
                        </pre>
                        However, this only changes the state of the boolean.  Now we need to use that boolean to make some thing happen.  Lets say if the boolean is true, turn on the led, if its false turn off the led.
                        <pre>

                        boolean = ledState; // variable for the state of our led
                        int led = 7; // connect the led to pin 7
                        int interval = 500; // set interval for triggering actions (maybe blink an LED)
                        long currentTime; // variable to store our millis(), use long instead of int 
                        long lastTime; // timestamp for the last time we triggered, use long instead of int
                    
                        void setup() { 
                          Serial.begin(9600); // start serial so we can debug 
                          pinMode(led, OUTPUT);
                          lastTime = millis(); // set our "timestamp" when we turn on our program.
                          ledState = false; // start with our led trigger off
                        }
                            
                        void loop() {

                          currentTime = millis(); // continuously update the 

                          if (currentTime - lastTime > interval) { // check the passage of time
                            Serial.println("Hey 500 millis has passed") // trigger a serial println
                            
                            ledState = !ledState            // change ledState to the opposite of what it was previously

                            lastTime = millis();           // update the timestamp so we can continue keeping track

                          }

                          if (ledState == true){         // if the ledState is true....

                                digitalWrite(led, HIGH); // turn on the led

                            }else{                       // if the ledState is false....
                                
                                digitalWrite(led, LOW);  //turn off the led
                            }
                        }
                        </pre>

                        Now we have a system where our time is independent of <code>delay()</code> so our code will not be blocked. This also means we can update our blink rates just by changing our interval variable instead of writing many lines of <code>delay()</code> over and over. We are also now able to turn our led on and off by setting the <code>ledState</code> to be either <code>true</code> or <code>false</code>.  Meaning we can have it on a timer but we can also turn it on or off based on any other conditions with out having to write extra <code>digitalWrite()</code> or <code>delay()</code>

                    </ul>
            </div>
             <div class="container" id="drawing">
                <h3>Class 5: Drawing in P5 </h3>
               
                
                <li><strong>P5:</strong></li>
                    <ul>
                        <li>Our code is like a blueprint, or a list of commands that the arduino will execute in order from top to bottom (mostly).  For the most part we can imagine that the arduino is reading our code line by line from top to bottom.  The Arduino will excute the code exactly as it is written, in order, line by line.  It is our job as programmers to remember that while the computer is fast and powerful, it is also very simplistic in how it reads and executes our code.</li> 

                        <li>Our code uses variables to store information and functions to do stuff with that information.  It also has a variety of logical operators and comparitors that allow us to compare things and program different behaviors for different situations.</li>   
                    </ul>
            </div>

            <div class="container" id="github">
                <h3>Git and Github </h3>
                 <li><strong>Git:</strong></li>
                <ul><a href="https://git-scm.com/download/mac">Download Git Here</a></ul>

                <li><strong>Github:</strong></li>
                <ul><a href="https://github.com/">Create a Github Account</a></ul>
            </div>

               <div class="container" id="motors">
                <h3>Motors </h3>
                 <li><strong>Git:</strong></li>
                <ul><a href="https://git-scm.com/download/mac">Download Git Here</a></ul>

                <li><strong>Github:</strong></li>
                <ul><a href="https://github.com/">Create a Github Account</a></ul>
            </div>



            <div class="container" id="telecom">

                <h3>Class 7: Telecommunication </h3>
                <h4>Anything Next To Anything (Anywhere)</h4>
                <p>Now by adding telecommunication, any element in one person's computer can be next any element on another person's computer.  We talked about how the random access nature of electronic storage allows any element in memory to be instantly juxtaposed with any other element.  Rearranging data into different versions is cheap and fast, which makes looking at things new ways easier, as when you change categories on this blog.  Creating new versions is democratized as compared with movable type or film where new versions take much more effort and expense.  Now your ideas can be more easily be juxtaposed with the ideas on any one else's computer on the planet into new versions.  This radically accelerates the possibilities for ideas being in the right place at the right time.</p>
                <p>For now we will talk between the Arduino and your laptop.   But the principles will be the same later when we connect any two computers on the internet.</p>

                <h4>Goal</h4>
                <p>We are trying to get some numbers or letters  from one of your sensors in Arduino out the USB cable into one of the variables controlling your display in P5 .  You might also try to go the other way get a variable in P5out the USB cable to the Arduino to say move the servo motor.  Sending one number is not so bad.  Sending multiple readings will require you to make a protocol for sending the readings separated by delimiters and then on arrival splitting and storing them into arrays.  That is a nice challenge for you.</p>

                <h3>Circuit</h3>
                <img src="https://itp.nyu.edu/physcomp/wp-content/uploads/potentiometer_schem1-261x300.png" alt="" width="261" height="300" /><img class="alignnone" src="https://itp.nyu.edu/physcomp/wp-content/uploads/potentiometer_bb.png" alt="" width="305" height="192" />
                <p>Wire up a potentiometer to your arduino. Using analogRead() and your Serial Monitor.  Double check that you are getting sensor readings from your potentiometer:</p>

                <pre>void setup() {
                  Serial.begin(9600);
                }

                void loop() {
                  int reading = analogRead(A0);
                  int value = map(reading, 0, 1023, 0, 255);
                  Serial.println(value);
                }</pre>
                You should see something like this:

                <a href="http://itp.nyu.edu/classes/cc-f16/files/2014/02/serialMonitor.png"><img src="http://itp.nyu.edu/classes/cc-f16/files/2014/02/serialMonitor-300x272.png" alt="serialMonitor" width="300" height="272" /></a>
                <h4>Protocol</h4>
                <p>Communication is hard when you make up your own words.  Both sides have to agree on a protocol, that is a the conventions of the communication, ahead of time.  Because you will be controlling both sides of the communication, Arduino and P5, you really only have to agree with yourself.  There is a whole stack of electrical agreements that you don't have to worry about because they were set for you, for instance that there is one wire for transmit and one wire for receive in the USB cable and electrical pulses get sent one right after another (serially).  The conventions of your protocol will mostly be about formatting the message that you are sending.</p>

                <h4>Baud Rate</h4>
                <p>The only important agreement about the electrical signal that you control is the speed in which the pulses come along.  This is called the baud rate.  The most common baud rate is 9600 baud which will send a byte (a letter or a number between 0-255) every millisecond.  9600 is pretty common and you will probably never change this one so this is not very interesting.  Sorry.</p>

                <h4>Sending on the Arduino Side</h4>
                <p>You have already done the Arduino side of this when you were debugging by sending from your Arduino to your laptop using Serial.begin(9600) and then Serial.println(myVar).  Back on your laptop you had to click on the "Serial Monitor" and make sure it was agreeing with the 9600 baud.</p>
                <p>But now we're going to try the same thing with a small difference.</p>

                <pre>void setup() {
                  Serial.begin(9600);
                }

                void loop() {
                  int reading = analogRead(A0);
                  int value = map(reading, 0, 1023, 0, 255);
                  Serial.write(value);
                }</pre>
                <p>Notice there is one small change compared to the analog debugging output example.  Instead of "<strong>Serial.println</strong>"  We are sending out information using "<strong>Serial.write</strong>" .  IF you were to open your Serial Monitor now, the output will look like this:</p>
                <p><a href="http://itp.nyu.edu/classes/cc-f16/files/2014/03/Serial-Write-Output.png"><img class="alignnone size-medium wp-image-2973" src="http://itp.nyu.edu/classes/cc-f16/files/2014/03/Serial-Write-Output-300x193.png" alt="Serial Write Output" width="300" height="193" /></a></p>
                <p>Do not be alarmed.  Even though it looks like garbled nonsense, this is actually what we are expecting to see.  But why?</p>
                <p><a href="#serPWR"> We'll get to it later.</a></p>

                <h4>Listening on the P5 Side</h4>
                <p>Listening in P5 is a little more involved.  You have to:</p>

                <ol>
                    <li>Download the latest <a href="https://github.com/vanevery/p5.serialcontrol/releases">p5.serialcontrol app</a> , save it to your applications</li>
                    <li>In the p5 editor: Import the  p5js serialport Library</li>
                    <li>Open the p5.serialcontrol app</li>
                    <li>Make a Serial Object Variable</li>
                    <li >Find the Right USB port in the Setup Function and use <strong>new</strong> to make a serial object.</li>
                    <li >Make a Callback Function (several actually....) to Listen to Incoming Messages.</li>
                </ol>
                <h4 >Import the Serial Library</h4>
                <p>Because USB serial port is different on every different kind of computer (eg mac, pc),  is not part of the core of P5 (or javascript).  Instead you have to extend P5 with the appropriate library for doing it on your particular hardware platform.  Luckily for you, the library for your machine downloaded with P5 when you installed it.  So all you have to do is let P5 know adding the p5.serialport.js file to your libraries folder (there is even a menu option that does it for you).</p>
                <p><strong><a href="http://itp.nyu.edu/classes/cc-f16/files/2014/03/importserial2.png"><img class="alignnone size-medium wp-image-2963" src="http://itp.nyu.edu/classes/cc-f16/files/2014/03/importserial2-300x188.png" alt="importserial2" width="300" height="188" /></a> <img class="alignnone size-medium wp-image-2964" src="http://itp.nyu.edu/classes/cc-f16/files/2014/03/seriallib-300x283.png" alt="seriallib" width="300" height="283" /></strong></p>

                <h4>Serial Object</h4>

                <p>Welcome to object oriented programming!  Until now we have been using variables to store number or letters.  Now we are going to use a variable to store an object.  An object not only has numbers and letters (data) but also functions for doing things (behavior).  So at the top you declare a variable of type "Serial" meaning you are going to store a Serial object in it.</p>

                <pre>var serial;</pre>
                <p >Initializing Objects: We typically use the <strong>new</strong> command with some parameters, in this case which port (more on that in a minute) and it returns an object for you to store in your variable.  This is usually done in setup.</p>

                <pre>function setup() {
                 serial = new p5.SerialPort(); // make a new instance of the serialport library
                }</pre>
                <h4>Start the Serial Server</h4>
                To communicate with your microcontroller serially, you’re going to use the P5.js serialport library and the P5.js editor. The P5.js serialport library can’t access your serial ports directly when a sketch is running in a browser or in the P5 sketch window. But it can communicate with a server program on your computer that can exchange data with the serialport. The P5 editor acts as the server that connects your sketch, running in a browser or sketch window, with the serial ports on your computer as shown below:

                <img src="https://itp.nyu.edu/physcomp/wp-content/uploads/socket-serial-connection-1.png" alt="" width="921" height="270" />

                &nbsp;

                The P5.js serial server uses the <a href="http://www.nodejs.org/">node.js programming environment</a> to create the serial-to-webSocket server that allows you to connect your sketch to the serial port.

                The P5.serialport library can only work with the serial-to-webSocket server that’s built into the P5 editor.  In order to run a sketch that utilizes serial communication make sure you start your Serial Server before you run your sketch:

                <a href="http://itp.nyu.edu/classes/cc-f16/files/2014/03/serialServer.png"><img src="http://itp.nyu.edu/classes/cc-f16/files/2014/03/serialServer-300x66.png" alt="serialServer" width="300" height="66" /></a>
                <h4>Pick a Port in Setup</h4>
                The P5 version of the "setup" is slightly more complicated than Arduino because there can be more than one USB cable plugged into your laptop.  Most of the time this code will just work because your Arduino will be the first (zeroth) USB serial port that P5 looks for.  Other times you will have to run your program once and then look in the output box at the list of ports that result from "println(i+" "+portList[i])"   The port names are not very friendly especially on the mac they look like "/dev/tty.usbmodem1421" and on the PC some like "COM1"   It is not easy to find the one that belongs to the Arduino but you can try unplugging the arudino and see which one disappears.  You already set this in the Arudino software so you can also look there under the "Tools&gt;Port" menu.  You can either supply the string like "/dev/tty.usbmodem1421" or you can pull the name by number from the list of ports as happens in the sample code here.
                <pre>var serial; // variable to hold an instance of the serialport library
                 
                function setup() {
                 serial = new p5.SerialPort(); // make a new instance of the serialport library
                 serial.on('list', printList); // set a callback function for the serialport list event
                 
                 serial.list(); // list the serial ports
                }
                 
                // get the list of ports:
                function printList(portList) {
                 // portList is an array of serial port names
                 for (var i = 0; i &lt; portList.length; i++) {
                 // Display the list the console:
                 println(i + " " + portList[i]);
                 }
                }</pre>
                <h4>Baud Rate (again)</h4>
                <p >This has to match your Arduino's baud rate setting in order for P5 to communicate correctly.</p>

                <pre>var options = { baudrate: 9600}; // change the data rate to whatever you wish as long as it matches the arduino
                serial.open(portName, options);</pre>
                <h4>Events and Callbacks</h4>
                <p>JavaScript, the language on which P5.js is based, relies heavily on <strong>events</strong> and <strong>callback functions</strong>. An <strong>event</strong> is generated by the operating system when something significant happens, like a serial port opening, or new data arriving in the port. In your sketch, you write a <strong>callback function</strong> to respond to that event. The serialport library uses events and callback functions as well. It can listen for the following serialport events:</p>

                <ul>
                    <li>list – the program asks for a list of ports.</li>
                    <li>connected – when the sketch connects to a webSocket-to-serial server</li>
                    <li>open – a serial port is opened</li>
                    <li>close – a serial port is closed</li>
                    <li>data – new data arrives in a serial port</li>
                    <li>error – something goes wrong.</li>
                </ul>
                You’re already using a callback for the ‘list’ event in the code above. You set a callback for the ‘list’ event, then you called it with <tt>serial.list()</tt>. Generally, you should set your callbacks before you use them like this.
                <pre>var serial;          // variable to hold aninstance of the serialport library
                var portName = '/dev/cu.usbmodem1421';  // use your serial port name here
                 
                function setup() {
                  serial = new p5.SerialPort();       // make a new instance of the serialport library
                  serial.on('list', printList);  // set a callback function for the serialport list event
                  serial.on('connected', serverConnected); // callback for connecting to the server
                  serial.on('open', portOpen);        // callback for the port opening
                  serial.on('data', serialEvent);     // callback for when new data arrives
                  serial.on('error', serialError);    // callback for errors
                  serial.on('close', portClose);      // callback for the port closing
                 
                  serial.list();                      // list the serial ports
                  serial.open(portName);              // open a serial port
                }
                </pre>
                Now add new functions to respond to the callbacks you just declared. These come after your <tt>setup()</tt>function:
                <div>
                <div>
                <pre>function serverConnected() {
                  println('connected to server.');
                }
                 
                function portOpen() {
                  println('the serial port opened.')
                }
                 
                function serialEvent() {
                 
                }
                 
                function serialError(err) {
                  println('Something went wrong with the serial port. ' + err);
                }
                 
                function portClose() {
                  println('The serial port closed.');
                }</pre>
                </div>
                </div>
                Most of these functions just provide notification. The error function is a bit more useful because it tells you what went wrong if something went wrong. If you didn’t change the portName variable to the name of your microcontroller’s serial port, for example, you probably got this error:
                <pre><tt>
                Something went wrong with the serial port. Couldn't open port: /dev/cu.usbmodem1421
                </tt></pre>
                The function that matters the most, though, is <tt>serialEvent()</tt>, the one that responds to new data. Each time a new byte arrives in the serial port, this function is called. Now it’s time to make serialEvent() do some work. Add a new global variable at the top of your sketch called <tt>inData</tt> like so:
                <div>
                <div>
                <pre>var serial;          // variable to hold an instance of the serialport library
                var portName = '/dev/cu.usbmodem1421';  // fill in your serial port name here
                var inData;                             // for incoming serial data</pre>
                </div>
                </div>
                Then modify the <tt>serialEvent()</tt> function like so:
                <pre>function serialEvent() {
                  inData = Number(serial.read());
                }</pre>
                Although you’re reading the incoming data, you’re not displaying it anywhere yet. Add a <tt>draw()</tt> function and print the sensor value to the screen. Start by adding a <tt>createCanvas()</tt> to the top of your <tt>setup()</tt> like so:
                <pre>function setup() {
                  createCanvas(400, 300);
                }</pre>
                Then here’s your <tt>draw()</tt> function:
                <div>
                <div>
                <pre>function draw() {
                  background(0);
                  fill(255);
                  text("sensor value: " + inData, 30, 30);
                }</pre>
                </div>
                </div>
                When you run your sketch now, you should get something like this:

                <img src="https://itp.nyu.edu/physcomp/wp-content/uploads/readSerial-screenshot.png" alt="" width="512" height="467" />
                <h4>Sending on the Arduino Side (again)</h4>
                <p>You have already done the Arduino side using <strong>Serial.write</strong>. You've also done this when you were debugging by sending from your Arduino to your laptop using <strong>Serial.begin(9600)</strong> and then <strong>Serial.println()</strong>.  Back on your laptop you had to click on the "Serial Monitor" and make sure it was agreeing with the 9600 baud.  Let's try using <strong>Serial.print</strong> and <strong>Serial.println</strong> again.</p>

                <pre>void setup() {
                  Serial.begin(9600);

                }

                void loop() {
                  int reading = analogRead(A0);
                  int value = map(reading, 0, 1023, 0, 255);
                  Serial.print(value);
                  Serial.print('\r');
                  Serial.print('\n');
                }</pre>
                &nbsp;
                <p>Notice there is one small change compared to the analog debugging output example.  The "<strong>ln</strong>" is missing at the end of "<strong>println</strong>".  The <strong>println</strong> function automatically appends a carriage return character '<strong>\r</strong>' and new line character '<strong>\n</strong>' to whatever message we want to print.   In the code above we are using <strong>Serial.print</strong> to explicitly send out those characters.</p>
                <p>Try printing out your potentiometer readings both ways, try the code above and see what the serial monitor reads.  Then replace the three <strong>Serial.print()</strong> commands with just one <strong>Serial.println().</strong></p>

                <pre>void setup() {
                  Serial.begin(9600);
                }

                void loop() {
                  int reading = analogRead(A0);
                  int value = map(reading, 0, 1023, 0, 255);
                  Serial.println(value);
                }</pre>
                In either case you should see something like this:
                <p><a href="http://itp.nyu.edu/classes/cc-f16/files/2014/02/serialMonitor.png"><img src="http://itp.nyu.edu/classes/cc-f16/files/2014/02/serialMonitor-300x272.png" alt="serialMonitor" width="300" height="272" /></a></p>
                <p>The next step is really just replacing the Serial Monitor on your laptop with P5 on your laptop.  You might still test everything out with the Serial Monitor first to make sure the Arduino side is right before trying with P5.  Make sure you close the Serial Monitor because it should not be open at the same time as P5.</p>
                &nbsp;
                <h4>Listening is Harder Than Talking</h4>
                <p>In Software, as in person, it is easy to know you have to pay attention when speaking.  Because you don't know exactly when someone else is going to speak you have to always be ready to hear which is difficult. The technical term here is <strong>Asynchronous Communication</strong>.  You could use a "blocking function" which stop the whole program to watch for something coming in the port.  Computers have few tricks to save you from dedicating your whole program to waiting for the next thing to come in.</p>
                <p>The first feature is called a buffer which is a little waiting room where the computer seats incoming bytes (in order) for you until your program has time to grab them an use them.  The serial buffer is made for you automatically in the setup.</p>
                <p>The second feature is called a control character.  This is a character that is added to the the end of our communication to signal the end of our transmission</p>
                <p>We will use <strong>callbacks </strong>to check when we have received information as well as when we should send information</p>
                <p><strong>CALL BACK METHOD:</strong> We want P5 to call a function when there is some action on the USB cable.  By making the serial object in setup, behind the scenes you subscribed to a service that will call our <strong>serialEvent</strong> function whenever something comes into the buffer.  You have already seen this concept of callbacks with MousePressed() and KeyPressed() for user input which is also asynchronous, meaning you never know exactly when it is going to happen.</p>
                <p>Also instead of printing the number like before, lets use that number to move an ellipse:</p>

                <pre>var serial;
                var inData;
                var options = {
                  baudrate: 9600
                };
                var portName = '/dev/cu.usbmodem621';

                function setup() {
                  createCanvas(400, 400);
                  serial = new p5.SerialPort(); // make a new instance of the serialport library
                  serial.on('list', printList); // set a callback function for the serialport list event
                  serial.on('connected', serverConnected); // callback for connecting to the server
                  serial.on('open', portOpen); // callback for the port opening
                  serial.on('data', serialEvent); // callback for when new data arrives
                  serial.on('error', serialError); // callback for errors
                  serial.on('close', portClose); // callback for the port closing
                  serial.open(portName, options); // open a serial port
                }


                function draw() {
                  background(0);
                  fill(255);
                  
                  ellipse(width / 2, inData, 30, 30);
                }

                function serialEvent() {
                  var inString = serial.readStringUntil('\r\n'); // hold info in the buffer until you see the control characters, and store that in our inString variable

                  if (inString.length &gt; 0) { //if we have any information, use it!
                    inData = Number(inString);
                    print(inData);
                  }
                }


                function serialError(err) {
                  println('Something went wrong with the serial port. ' + err);
                }

                function portClose() {
                  println('The serial port closed.');
                }

                function printList(portList) {
                  for (var i = 0; i &lt; portList.length; i++) {
                    println(i + " " + portList[i]);
                  }
                }


                function serverConnected() {
                  println('connected to server.');
                }

                function portOpen() {
                  println('the serial port opened.')
                }</pre>
                &nbsp;
                <h2>Control Characters</h2>
                <p>Congratulations you just made a protocol.  You are saying there will be a '\r' and a '\n' character between each reading.  '\r' is a carriage return and '\n' is the new line character.  The serial monitor uses these characters to put each reading on it's own line.  This is the extra bit that "println" sends as opposed to "print."  You will notice in the previous arduino example I am using just print and sending the carriage return and new line characters more explicitly with print('\r') print('\n') instead of println().   The new line is what is called a control character.  You see the results of it but the actual character is invisible so to give it a manifestation we use the single quotes followed by a back slash and the letter n for new line.  '\t' is the way your represent a tab, another invisible control character.  In general the back slash in text string is called a the <strong>escape character</strong> which tells the machine not to take the next character (in this case "n" or "t" ) at face value.  One other thing you will notice here is sometimes we use double quote and sometimes single quotes.  Because it is a single character we use a single quote in this case.  Hopefully you will get used to this stuff.</p>

                <h4>ReadStringUntil('\r\n')</h4>
                <p>This  is a really great function that looks in the buffer to see if the whole message has arrived yet.   If the '\r\n' characters are not in the buffer it means your full message has not arrived yet and it puts <strong>null</strong> or <strong>undefined</strong>  into the variable.  If it the carriage return and new line characters are in there that means that the full message has arrived and this function call  pulls it out of the waiting buffer and puts it in your variable.</p>

                <h4>Trim()</h4>
                <p>This cleans off the invisible control characters that will screw things up.</p>

                <h4>Number()</h4>
                <p>This converts the incoming message from a String to a number (much more on this below).</p>
                <p><strong>You Don't Really Need to Know This</strong>: (How the Computer get bigger numbers from a group of 1's and 0's which is all it knows) As we have seen before these computers are really only capable of 1's and 0's.  Now we are really just sending a serial stream of pulses of yes and no over the wire.  To express bigger numbers we group a bunch of 1's or 0's (aka bits)  into groups of 8 bits (aka bytes).  We are always sending bytes back and forth.  Then each unique permutation of the 8 bits represents a number between 0 and 255 (there are 256 different permutations of eight 1's and 0's). The actual method for getting the decimal from a eight ones and zeros is something you may never need to know but I will tell you anyway.  Basically each place has a weight and you add up the weight of all the places where there was a one.</p>
                <p style="padding-left: 60px;">Position Weights: 1   2   8   16   32  64  128
                Number: 1  0  0  1   0    0    0   = 17
                Number: 0  1  1  0   0   1    0    =  74</p>

                <h4 id="serPWR">Sending and Receiving Numbers</h4>
                <p>The simplest way to communicate would have been to use the .write() and .read() functions (same on both Arduino and P5).  These send numbers as single bytes back and forth which would seem to make sense because often the message begins its life as a number (eg analogRead()) and completes its mission as a number (eg ellipse(xpos,10,10,10)).  But we probably won't be doing this in sending from Arduino to P5.</p>

                <h4>Text from Numbers</h4>
                <p>Humans prefer to communicate more with words than numbers so we often make one further conversion from numbers to letters using an ASCII table.  The first 32 characters are those invisible control characters we were just talking about. You can also refer to them by number, for instance, 10 for '\n' (although sometimes it is 10  and 13).</p>

                <table border="0" width="80%" cellspacing="0" cellpadding="5">
                <tbody>
                <tr>
                <td valign="top" width="20%">
                <pre>DEC     Character
                Value

                0   null
                1
                2
                3
                4
                5
                6
                7
                8
                9   tab 
                10  line feed   
                11
                12
                13  carriage return
                14
                15
                16
                17
                18
                19
                20
                21
                22
                23
                24
                25
                26
                27
                28
                29
                30
                31</pre>
                </td>
                <td valign="top" width="18%">
                <pre>DEC     Character
                Value

                32  space
                33  !
                34  "
                35  #
                36  $
                37  %
                38  &amp;
                39  '
                40  (
                41  )
                42  *
                43  +
                44  ,
                45  -
                46  .
                47  /
                48  0
                49  1
                50  2
                51  3
                52  4
                53  5
                54  6
                55  7
                56  8
                57  9
                58  :
                59  ;
                60  &lt;
                61  =
                62  &gt;
                63  ?</pre>
                </td>
                <td valign="top" width="18%">
                <pre>DEC     Character
                Value

                64  @
                65  A
                66  B
                67  C
                68  D
                69  E
                70  F
                71  G
                72  H
                73  I
                74  J
                75  K
                76  L
                77  M
                78  N
                79  O
                80  P
                81  Q
                82  R
                83  S
                84  T
                85  U
                86  V
                87  W
                88  X
                89  Y
                90  Z
                91  [
                92  \
                93  ]
                94  ^
                95  _</pre>
                </td>
                <td valign="top" width="18%">
                <pre>DEC     Character
                Value

                96  `
                97  a
                98  b
                99  c
                100 d
                101 e
                102 f
                103 g
                104 h
                105 i
                106 j
                107 k
                108 l
                109 m
                110 n
                111 o
                112 p
                113 q
                114 r
                115 s
                116 t
                117 u
                118 v
                119 w
                120 x
                121 y
                122 z
                123 {
                124 |
                125 }
                126 ~
                127</pre>
                &nbsp;</td>
                </tr>
                </tbody>
                </table>
                <h4>Sending and Receiving Text</h4>
                <p>Usually I recommend that you go the extra step of turning your numbers into text using print() (intend of write()) and read them as text using readString() (instead of read()) as I have been doing in the  above  examples (except the polling example).  Here are the reasons it is better to send numbers as text:</p>

                <ol>
                    <li>Debugging is easier with text.   Tools like the Serial Monitor can only really display text.  Numbers  get translated by the ASCII table by the Serial Monitor anyway and end up looking like all sorts of nonsense characters.</li>
                    <li>It is easier to send arbitrarily long numbers with text because sending each number as a byte limits you to numbers between 0-255.  With text you can just keep adding a byte for every new digit as new letter in the string.</li>
                    <li>It is is easier to send multiple numbers as text because you can use text things like comma's and control characters as separators (delimiters) between the numbers.</li>
                </ol>
                <h4>I am Confused How Can a Letter Be A Number?</h4>
                <p><span>You will see in the ascii chart that character number 48-58 are "alphanumeric characters."   When you send out a number using the <strong>Serial.print() </strong>the Arduino uses the ASCII table to look for the number of the alphanumeric character for each digit.  For instance to send "1008" it would send four bytes, 49,48,48,56.  If you were using <strong>println</strong> it would send a fifth character 49,48,48,56,10.  If you see a lot of numbers in this range coming by in your debug windows it probably means you are interpreting numbers sent as text using the print command when sending but then interpreting them as numbers using the read() command on receiving.  Being consistent about interpreting things as either numbers or text on both sides of the conversation is probably the most important protocol decision you will make.  When talking from Arduino to P5 I recommend you send and receive as text using the print and readString commands (if you want to).<strong>
                </strong></span></p>

                <h4>Sending Multiple Things From Arduino to P5</h4>
                <p><a href="http://itp.nyu.edu/classes/cc-f16/files/2014/03/serialPotSwitch_bb.png"><img class="alignnone size-medium wp-image-2997" src="http://itp.nyu.edu/classes/cc-f16/files/2014/03/serialPotSwitch_bb-242x300.png" alt="serialPotSwitch_bb" width="242" height="300" /></a> <a href="http://itp.nyu.edu/classes/cc-f16/files/2014/03/serialPotSwitch_schem.png"><img class="alignnone size-medium wp-image-2998" src="http://itp.nyu.edu/classes/cc-f16/files/2014/03/serialPotSwitch_schem-300x204.png" alt="serialPotSwitch_schem" width="300" height="204" /></a></p>
                <p>Suppose you wanted to make a game controller with a force sensitive resistor for controlling your movement and switch for firing.  You would want to send two numbers from Arduino to P5.  We were already using the '\n' character to delimit between messages.  You need a new delimiter to separate the values from the two different sensors.  Luckily because you are only using characters 48-58 in the ASCII chart for alpha numeric characters, all of  the others are available for another delimiter.  The most common ones are commas or another control character, tab '\t'.  Now your protocol is getting a little more detailed.  Whatever you pick as a delimiter, it just can't show up in the delimiter.  Later on you might look at HTML code where they use &lt;&gt; or json where they use {} and : for delimiters.</p>
                <p>Here is the Arduino Code.  I added a comma and a second sensor (a switch) and sent everything out separated by commas.</p>

                <pre>void setup(){
                  Serial.begin(9600);
                }

                void loop(){
                  int pot = analogRead(0);
                  int button = digitalRead(7);
                  Serial.print(pot);  //notice I did not say println
                  Serial.print(","); //using the comma as a delimiter
                  Serial.println(button); // using println instead of print to automatically add my control characters
                }</pre>
                <p>On the P5 side both sensors arrive in the order they were sent as one long string of text.  We break it into parts using the <strong>split()</strong> function.  We need something called an array variable that can hold multiple things in one variable.  Arrays have one name like the usual variables but then have multiple numbered slots for storage.  The tell tale sign of an array variable is the square brackets.  You will see this <strong>parts</strong> variable is declared as String[ ] instead of String.  This kind of parsing of text based on delimiters is the most common task in computer communication so get used to it.</p>

                <pre>var serial;          // variable to hold an instance of the serialport library
                var portName = '/dev/cu.usbmodem1411'; // fill in your serial port name here
                 
                var ypos;        // y location of the circle
                var circleColor = 255; // color of the circle

                function setup() {
                 createCanvas(640, 480);          // make canvas
                 smooth();                        // antialias drawing lines
                 serial = new p5.SerialPort();    // make a new instance of the serialport library
                 serial.on('list', printList);    // set a callback function for the serialport list event
                 serial.on('connected', serverConnected); // callback for connecting to the server
                 serial.on('open', portOpen);     // callback for the port opening
                 serial.on('data', serialEvent);  // callback for when new data arrives
                 serial.on('error', serialError); // callback for errors
                 serial.on('close', portClose);   // callback for the port closing
                 
                 serial.list();                   // list the serial ports
                 serial.open(portName);           // open a serial port
                }

                function draw() {
                 background(0);               // black background
                 fill(circleColor);           // fill depends on the button
                 ellipse(width/2, ypos, 50, 50); // draw the circle
                }

                function serialEvent() {
                  // read a string from the serial port
                  // until you get carriage return and newline:
                  var inString = serial.readStringUntil('\r\n');
                 
                  //check to see that there's actually a string there:
                  if (inString.length &gt; 0 ) {
                    var sensors = split(inString, ',');            // split the string on the commas
                    if (sensors.length &gt; 1) {                      // if there are two elements
                      ypos = map(sensors[0], 250, 410, 0,width);   // element 0 is the ypos
                      circleColor = 255 - (sensors[1] * 255);      // element 1 is the button
                    }
                  }
                }</pre>
                &nbsp;
                <h4>Sending From P5 to Arduino</h4>
                <p>For talking back from P5 to Arduino, I suggest you just send numbers instead of letters using the write()  from P5 and read() in Arduino  (not print() and readStringUntil()).</p>

                <h4>Synchronizing:</h4>
                <p>Sometimes you just want to send a character back to Arduino to say you are ready for a new message.  If your Arduino sent stuff faster than P5 can use it, data will get backed up in the buffer.  We are using the if statement to check if something is available, meaning P5 sent something before we send something back.   In this case the content of the message is unimportant.</p>
                <p>Note we are also using a while loop in our setup() to check if the Serial port is open.  So as long as the serial port is NOT open, the arduino will print "hello" every 300 milliseconds to initiate contact.  Once the port is open, P5 will (finally) receive the "hello" message and we can proceed to the loop.</p>
                <p>And still, in the loop we are using an if statement to continue checking if P5 is still ready to communicate.  So once the port is open we still want to continue to check if P5 is ready for communication.</p>

                <pre>void setup() {
                  Serial.begin(9600);
                  pinMode(7, INPUT);

                  while (Serial.available() &lt;= 0) {
                    Serial.println("hello");
                    delay(300);
                  }

                }

                void loop() {
                  if (Serial.available() &gt; 0) {
                    //Serial.read();
                    //we did it to slow things down for synchronization
                    //notice we didn't even put the number in anything

                    int pot = analogRead(A0);
                    int button = digitalRead(7);
                    Serial.print(pot);  //notice I did not say println
                    Serial.print(","); //using the comma as a delimiter
                    Serial.println(button);
                  }
                }</pre>
                &nbsp;
                <p>Now you have to make sure to send something to Arduino to feed the "if available". It is easy to wind up in the situation where both sides are locked up waiting for something to be sent by the other side. You should send in serialEvent so Arduino is prodded to send a new value every time P5 gets a new one.  We call this call and response or handshaking.  But you should also send a character right in setup in P5 to prime the pump so you don't get into a situation where both sides are waiting to hear from the other.</p>
                <p>the important parts:</p>

                <pre>function serialEvent() {
                 // read a string from the serial port
                 // until you get carriage return and newline:
                 var inString = serial.readStringUntil('\r\n');

                 //check to see that there's actually a string there:

                 if (inString.length &gt; 0) {
                 
                 if (inString !== "hello") { //ignore the initial hello, but if its not hello, then it must be numbers!

                 var sensors = split(inString, ','); // split the string on the commas

                 if (sensors.length &gt; 1) { // if there are two elements in the array
                 ypos = map(Number(sensors[0]), 0, 1023, 0, height); // element 0 is the ypos
                 // print("ypos: " + ypos);
                 circleColor = 255 - (Number(sensors[1]) * 255); // element 1 is the button
                 // print("circle color: " + circleColor);
                 }
                 }
                 serial.write('x'); // ask for more information after P5 has processed whatever it has received.
                 }
                }</pre>
                <p>full code:</p>

                <pre>var serial; // variable to hold an instance of the serialport library
                var portName = '/dev/cu.usbmodem621'; // fill in your serial port name here

                var ypos = 0; // y location of the circle
                var circleColor = 255; // color of the circle

                function setup() {
                 createCanvas(640, 480); // make canvas
                 smooth(); // antialias drawing lines
                 serial = new p5.SerialPort(); // make a new instance of the serialport library
                 serial.on('list', printList); // set a callback function for the serialport list event
                 serial.on('connected', serverConnected); // callback for connecting to the server
                 serial.on('open', portOpen); // callback for the port opening
                 serial.on('data', serialEvent); // callback for when new data arrives
                 serial.on('error', serialError); // callback for errors
                 serial.on('close', portClose); // callback for the port closing

                 serial.list(); // list the serial ports
                 serial.open(portName); // open a serial port
                }

                function draw() {
                 background(0); // black background
                 fill(circleColor); // fill depends on the button
                 ellipse(width / 2, ypos, 50, 50); // draw the circle
                }

                function serialEvent() {
                 // read a string from the serial port
                 // until you get carriage return and newline:
                 var inString = serial.readStringUntil('\r\n');

                 //check to see that there's actually a string there:

                 if (inString.length &gt; 0) {
                 
                 if (inString !== "hello") {

                 var sensors = split(inString, ','); // split the string on the commas

                 if (sensors.length &gt; 1) { // if there are two elements
                 ypos = map(Number(sensors[0]), 0, 1023, 0, height); // element 0 is the ypos
                 // print("ypos: " + ypos);
                 circleColor = 255 - (Number(sensors[1]) * 255); // element 1 is the button
                 // print("circle color: " + circleColor);
                 }
                 }
                 serial.write('x');
                 }
                }

                function serialError(err) {
                 println('Something went wrong with the serial port. ' + err);
                }

                function portClose() {
                 println('The serial port closed.');
                }

                function printList(portList) {
                 for (var i = 0; i &lt; portList.length; i++) {
                 println(i + " " + portList[i]);
                 }
                }


                function serverConnected() {
                 println('connected to server.');
                }

                function portOpen() {
                 println('the serial port opened.')
                }</pre>
                <h4>Sending Values from P5 to Arduino and from Arduino Back to P5 (NOW WITH A MOTOR)</h4>
                <a href="http://itp.nyu.edu/classes/cc-f16/files/2014/03/servo_bb.png"><img class="alignnone size-medium wp-image-2995" src="http://itp.nyu.edu/classes/cc-f16/files/2014/03/servo_bb-239x300.png" alt="servo_bb" width="239" height="300" /></a> <a href="http://itp.nyu.edu/classes/cc-f16/files/2014/03/servo.png"><img class="alignnone size-medium wp-image-2996" src="http://itp.nyu.edu/classes/cc-f16/files/2014/03/servo-247x300.png" alt="servo" width="247" height="300" /></a>

                Sometimes you actually want to send a real value from P5 to Arduino not just a nonsense byte for synchronization.  Here is an example where I am using the mouseX in P5 to move a servo motor in Arduino.  And just for kicks lets also use P5 to visualize at what angle the motor is currently positioned.  Here is the P5 sending side:
                <pre>var serial;
                var options = {
                  baudrate: 9600
                };
                var portName = '/dev/cu.usbmodem621'; // your serial port goes here
                var mpos = 0;
                var inData;

                function setup() {
                  createCanvas(600, 400);
                  serial = new p5.SerialPort(); // make a new instance of the serialport library
                  serial.on('list', printList); // set a callback function for the serialport list event
                  serial.on('connected', serverConnected); // callback for connecting to the server
                  serial.on('open', portOpen); // callback for the port opening
                  serial.on('data', serialEvent); // callback for when new data arrives
                  serial.on('error', serialError); // callback for errors
                  serial.on('close', portClose); // callback for the port closing
                  serial.open(portName, options); // open a serial port
                }


                function draw() {
                  background(0);
                  fill(255);
                  ellipse(mouseX,height/2,20,20);
                  textSize(36);
                  text("Outgoing number: "+mpos,20,height-60);
                  text("Servo Angle: "+inData,20,height-20);
                }

                function mouseDragged() {
                  mpos = ceil(map(mouseX, 0, width, 0, 255));
                  mpos = constrain(mpos,0,255);
                  
                  serial.write(mpos);
                  
                }

                function serialError(err) {
                  println('Something went wrong with the serial port. ' + err);
                }
                 
                function portClose() {
                  println('The serial port closed.');
                }

                function printList(portList){
                  for (var i = 0 ; i&lt;portList.length; i++){
                    println(i+" "+portList[i]);
                  }
                }

                function serialEvent() {
                  inData = Number(serial.read());
                }

                function serverConnected() {
                  println('connected to server.');
                }
                 
                function portOpen() {
                  println('the serial port opened.')
                }
                </pre>
                &nbsp;

                <span>Here is the Arduino receiving side:</span>
                <pre>#include &lt;Servo.h&gt;      // include the servo library

                Servo servoMotor;       // creates an instance of the servo object to control a servo


                void setup() {
                  Serial.begin(9600);       // initialize serial communications
                  servoMotor.attach(2);  // attaches the servo on pin 2 to the servo object
                }

                void loop(){
                  if (Serial.available() &gt; 0){
                     int input = Serial.read();  //this waits for byte from P5
                     int servoAngle = map(input,0, 255, 0, 179); // Servo can only go from 0-179 degrees, map incoming values to those angles
                     servoMotor.write(servoAngle);       // move the servo using the angle from the sensor:
                     Serial.write(servoAngle);           // write back to P5 what angle the servo is at.
                  }
                }</pre>
                &nbsp;
                <h4>The Internet</h4>
                <p>Microcontrollers are moving away from being connected by USB towards being connected by WIFI.  Devices like the Arduino Yun, the Rasberry PI, the Beagle Bone all feel more like nodes on the internet.  Regardless of whether you use a wire or note,  the principles of sending bytes back and forth will be the same will be the same.</p>

                <h4>Helpful links</h4>
                <p><a href="https://itp.nyu.edu/physcomp/labs/labs-serial-communication/lab-serial-input-to-the-p5-js-ide/">ITP physcomp lab serial from Arduino to P5</a></p>
                <p><a href="https://itp.nyu.edu/physcomp/labs/labs-serial-communication/lab-serial-output-from-p5-js/">ITP physcomp lab serial from P5 to Arduino</a></p>
                <p><a href="https://itp.nyu.edu/physcomp/labs/labs-serial-communication/two-way-duplex-serial-communication-using-p5js/">ITP phsycomp lab two-way serial communication btwn P5 and Arduino</a></p>
                      
                  
            </div>

    </div>


        <footer class="footer">
            <div class="container">Art B2011 | Fall 2016, DIAP at CCNY | David Rios | Email: riosriosriosrios (_at_) gmail (_dot_) com | Office Hours: TH, F by appointment
            </div>
        </footer>

         <!-- Bootstrap core JavaScript
            ================================================== -->
            <!-- Placed at the end of the document so the pages load faster -->
       
        <script src="http://getbootstrap.com/dist/js/bootstrap.min.js"></script>
        <!-- <script src="js/app.js"></script> -->
        <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
        <script src="http://getbootstrap.com/assets/js/ie10-viewport-bug-workaround.js"></script>

       
    </body>
</html>